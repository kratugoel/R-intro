---
title: "Intro to R: Analyzing the GWAS Catalog"
author: Peter Carbonetto
date: February 7, 2017
output: 
  html_document:
    toc: true
    toc_float: true
    number_sections: true
    fig_caption: false
    theme: default
---

# About this document

This is an R Markdown Notebook.
[R Markdown](http://r4ds.had.co.nz/r-markdown.html) combines
[Markdown](http://daringfireball.net/projects/markdown), a popular,
easy-to-read plain text formatting syntax, with "chunks" of R
code. R Markdown notebooks can be easily rendered into various formats
(PDF, HTML, *etc.*) for sharing your code and results with 
collaborators.

This notebook contains code to reproduce some of my analyses of data from 
the [NHGRI-EBI GWAS Catalog](http://www.ebi.ac.uk/gwas/). The GWAS Catalog 
provides results from thousands of [genome-wide association 
studies](http://dx.doi.org/10.1001/jama.299.11.1335) of 
inherited diseases and completx traits. My aim in using the GWAS Catalog 
is to illustrate using R to process and analyze large-scale, complex 
tabular data. 

Importantly, the GWAS Catalog is very "messy" data; consider
that hundreds of people have inputted data into the database, with only 
partial checks on data quality. In our analyses, we will have to manipulate 
and filter the data in order to make sense of it.

For background on the GWAS Catalog, see the 
[GWAS Catalog paper](http://doi.org/10.1093/nar/gkt1229). See also the 
[GWAS Diagram](http://www.ebi.ac.uk/gwas/diagram) for an evocative visual
summary of the data. 

# How to use this document

There are several ways to view this document:

1. The simplest option is to open it up in a text editor. I recommend 
   choosing a text editor that has syntax highlighting for Markdown, 
   such as emacs or [Atom](http://atom.io). 
   
2. Open this file in RStudio (see below for details).

3. Render, or "knit", this notebook into a format that is pleasant
   to read on the screen, such as PDF or HTML. In the same folder as
   this file, I have provided an example of an HTML file rendered from 
   this document, which can be viewed in your favourite Web browser.

## This notebook is an interactive document

Although you caneasily generate all the output and figures with a single 
command from the`rmarkdown` package (see below), my recommendation is to 
step through the code and explanations, and run the code on your own by 
copying and pasting the code into the R console, or by using the "Run" 
menu in RStudio.

# Introduce yourself

Introduce yourself to your neighbors. If you get stuck, please ask one your 
peers for help before asking the instructor. 

Conversely, if you have completed the steps more quickly than others, 
consider helping your neighbors.

# Setting up your R programming environment

There are several options for setting up your R programming environment. 
In this section, we will explore some of the R environment options that are 
available on the [midway compute cluster](https://rcc.uchicago.edu/docs) and 
on your laptop. *No single option is best for everyone.*

## R on your laptop

I recommend installing both R and RStudio. 

1. Install the latest precompiled binary distribution of R by following 
   the instructions on the [CRAN website](https://cran.r-project.org).
   This provides a text-based R programming environment.

2. Next, install the free version of RStudio Desktop from 
   [here](https://www.rstudio.com/products/rstudio/download).
   RStudio provides a complete IDE (integrated development environment)
   for R programming.

3. Try running R and RStudio on your computer. You can also try running
   R from a command-line shell (e.g., [iTerm2](https://iterm2.com) on Mac, 
  [Cygwin](http://www.cygwin.com) on Windows). To do so, simply type `R`,
  and hit the enter key.

4. Test your R graphics setup; e.g., try copying and pasting the code chunk 
   below into R or RStudio. in RStudio, this will (by default) draw the plot
   in the "Plots" tab. In R, this will render a plot on your screen, 
   *but only if you have X Windows software installed on your computer 
   already.* For example, for Mac OS X you need to have 
   [XQuartz](http://www.xquartz.org). 

```{r example_plot, eval=FALSE}
library(lattice)
print(xyplot(dist ~ speed,cars,pch = 20,
             cex = 1.5,col = "dodgerblue"))
```

## R on midway without graphics

Next, we explore how to run R in the command-line shell on the 
*midway* computer cluster. This approach is particularly useful for 
executing *non-interactive* computations in R; e.g., computations that 
may take several hours to run. I usually accompany the text-based R 
environment with a text editor (ideally one that has syntax 
highlighting) so that I can record my data analysis steps into an 
R script that can be run later.

I recommend using *midway2* instead of *midway1* because it has the 
most up-to-date version of R installed.

### Getting a midway user account

If you do not already have a [user account on
midway](http://rcc.uchicago.edu/getting-started/request-account),
the instructor or helpers can provide you with a
[YubiKey](https://www.yubico.com/start). This will allow you to access
*midway* for the duration of the workshop. (After the workshop, you
can request a proper user account
[here](https://rcc.uchicago.edu/getting-started/general-user-account-request)
provided you are associated with a Principal Investigator who already
has an RCC account.)

To access *midway* using the YubiKey, when prompted for your username,
enter `rccguestXXXX`, where `XXXX` is the last 4 digits shown on the
Yubikey:

![How to get username from YubiKey](../assets/yubikey1.gif)

Whenever a password is requested for this guest account, the (very
long) password will be automatically generated by lightly touching the
metal contact:

![How to generate password from YubiKey](../assets/yubikey2.gif)

### Connecting to midway

Log on to midway2 using ssh:

```{bash eval=FALSE}
ssh -X username@midway2.rcc.uchicago.edu
```

If you do not have an ssh program, or you are not sure how to access it,
move to the next section, "R on midway with graphics".

To illustrate "best practice", we will request an **interactive session** to allocate computational resources for our computations in R:

```{bash eval=FALSE}
sinteractive --time=02:00:00 --mem=2G --reservation=r_workshop
```

Outside the workshop, you will have to remove the `--reservation=r_workshop`
portion of this command.

See [here](https://rcc.uchicago.edu/docs/connecting/) for more details 
on connecting to the *midway* compute cluster.

(To safeguard against losing your Internet connection, I recommend using 
the **screen** command before running `sinteractive`. Explaining this command 
is outside the scope of this workshop, but you can read a tutorial on the 
screen command [here](http://www.howtoforge.com/linux_screen).)

### Loading and running R

Load the R 3.3 module, and start R:

```{bash eval=FALSE}
module load R/3.3
R --no-save
```

I include the `--no-save` flag because I don't like being asked whether
I want to save the results of my R session, but this is optional.

Once you are in R, let's print the first 5 rows of the Iris data table:

```{R iris, comment=NA}
print(head(iris,n = 5))
```

Once you have completed this step, quit R, and return to the shell 
environment:

```{R quit, eval=FALSE}
quit()
```

**Note:** In later episodes, we will omit the part about quitting R, so 
please remember how to do this.

### Running R code without entering the R environment

Although R is mainly used interactively, it is also possible to execute R code 
like other non-interactive programming languages (e.g., Java). To do this, we
use the `Rscript` command:

```{bash r_cmd_batch, eval=FALSE}
Rscript -e "print(head(iris,n = 5))"
```

More commonly, `Rscript` is used to execute R code stored in a file; 
e.g., `Rscript my_analysis.R`.

## R on midway with graphics

We have already explored R with graphics on your computer. How can we
visualize data in R on the *midway* compute cluster? There are several 
ways to do this. The recommended approach is to run R or RStudio in
[ThinLinc](http://www.cendio.com/thinlinc). Although the ThinLinc graphics
are not always crisp, it is the most reliable solution on our cluster.

1. Log in to ThinLinc. The simplest option is to use the 
[Web interface](http://midway.rcc.uchicago.edu). However, one drawback is that
it doesn't support copying and pasting very well. See 
[here](https://rcc.uchicago.edu/docs/connecting) for more information 
on connecting to midway using ThinLinc.

2. Open up a ROXTerm window by clicking the icon at the bottom that looks
   like a computer monitor.

3. Connect to midway2 with X forwarding:

```{bash thinlinc_midway2, eval=FALSE}
ssh -Y midway2-login1.rcc.uchicago.edu
```

4. Load and run either RStudio or R (or both!):

```{bash rstudio_graphics, eval=FALSE}
module load R/3.3
module load rstudio
rstudio
R --no-save
```

5. Test R graphics by copying and pasting the code chunk below into R 
   and/or RStudio.

```{r example_plot2, eval=FALSE}
library(lattice)
print(xyplot(dist ~ speed,cars,pch = 20,
             cex = 1.5,col = "dodgerblue"))
```

# Downloading the code

Now that we have explored several different R environment options, please
choose one of them for the remainder of the workshop. You will need an
environment that can generate graphics. The recommended option is to run
R or RStudio on *midway* because we have already installed the packages that
are necessary to complete this workshop.

In this section, we will download, or *clone*, all the files from the Github
repository. There are several ways this can be done:

1. Go to the [Github webpage](http://github.com/rcc-uchicago/R-intro) and 
   click the green "clone or download" button.

2. Download and unzip a ZIP file containing the entire repository 
   (this may only work on the compute cluster):

```{bash download_zip, eval=FALSE}
wget https://github.com/rcc-uchicago/R-intro/archive/master.zip
unzip master.zip
mv R-intro-master R-intro
```

3. Clone the repository using **git**:

```{bash clone_repo, eval=FALSE}
git clone https://github.com/rcc-uchicago/R-intro.git R-intro
```

Whatever approach you use, in the end, you should have a folder on your 
computer, or in your *midway* home directory, called `R-intro`.

Think of the `R-intro` folder as the main project folder; all files 
relevant to our data analysis project (code, data, *etc.*) should be 
saved within this folder. This will allow us to more easily keep track 
of our work.

Next, we will retrieve the data for our data analysis project.

# Downloading the data

1. Download the file that contains all associations with added ontology
   either by clicking [this 
   link](http://www.ebi.ac.uk/gwas/api/search/downloads/alternative), 
   or with the wget command:
   
```{bash wget_data, eval=FALSE}
wget http://www.ebi.ac.uk/gwas/api/search/downloads/alternative
mv alternative gwas_catalog.tsv
```

2. Copy this file to the [data](../data) folder in git repository, and 
   rename this file as `gwas_catalog.tsv`. 
   See [here](https://www.ebi.ac.uk/gwas/docs/fileheaders) for details on
   what is contained in this file.

Once you have completed these steps, the `R-intro` folder should have the 
following file structure:

```{bash repo_tree, eval=FALSE}
R-intro/
├── LICENSE
├── README.md
├── conduct.md
├── assets
├── data
│   ├── README.md
│   ├── gwas_catalog.tsv
│   └── gwas_catalog_small.xlsx
└── docs
    ├── README.md
    ├── demo_gwas_catalog.Rmd
    └── demo_gwas_catalog.html
```

# Setting the working directory in your R programming environment

Now return to your preferred R environment, either on your computer, or 
on the compute cluster. If you have exited, please repeat the steps above
to start a new environment.

To perform the data analysis, we need to make sure that our R
environment points to the `docs` folder of our project directory. 
One way to do this is using the `setwd` function in R. For example, if 
the `R-intro` files are in the `projects` folder in my home directory, 
do the following in R or RStudio:

```{R setwd, eval=FALSE}
setwd("~/projects/R-intro/docs")
```

Alternatively, RStudio has a "Set Working Directory" option in the "Session"
menu.

You can find out what your working by typing `getwd()`.

We are almost done with setting up our R environment. The last step is
to install some packages used in the data analysis.

# Installing and loading the packages

In R, a package is a set of functions, data sets, and other materials, 
that are bundled together. As of this writing, over 10,000 R packages have
been developed. The ease of installing and using packages is one of the 
reasons R has become so popular. Therefore, it is helpful to understand 
the steps in installing and loading packages.

Some packages are already available in your environment when you start R. 
One example is  the `stats` package because it contains basic functions 
that are widely used in statistical calculations.

```{R packages, eval=FALSE}
rmarkdown
readr
ggplot2
```

*Add instructions here for installing the required packages.*

## Executing the R code

**Add instructions here for running the code; give instructions from
RStudio, and using the RMarkdown command.**

## Reading the data into the R environment

The GWAS Catalog data set is a large table with 35,077 rows and 37 columns. 
It could conceivably be opened in Excel. To illustrate this, open the
[gwas_catalog_small.xlsx](/data/gwas_catalog_small.xlsx) spreadsheet, 
which contains the first 100 rows of the GWAS Catalog table. Here, we 
instead read the data into a "data frame" in R, which is R's standard data
structure for storing and working with tables:

```{r read_data, warning=FALSE, eval=TRUE, comment=NA}
library(readr)
gwas <- read_tsv("../data/gwas_catalog.tsv",na = c("","NA","NR"))
gwas <- as.data.frame(gwas,stringsAsFactors = FALSE)
print(colnames(gwas))
```

A lot is going on in just a few lines of code. I here are only a few of the 
many things that are important to know about these few lines of code:

+ We call a function `read_tsv` that is defined in the `readr` package.
  It is a specialized function for quickly reading data tables stored in 
  tab-delimited text format. You can learn more about this function by 
  typing `help(read_tsv)`.
  
+ We assign the output of this function to a variable called "gwas". This
  creates a new variable in our working environment. Type `ls()` to get
  the list of variables in the current environment.
  
+ Since the output from `read_tsv` is not a data frame, and we would like
  to work with a data frame, we convert it using the `as.data.frame` function.
  
+ The third line accesses a property of the data frame: the names of the
  columns in the table, or "data frame".

## Inspecting the data

Now that we have the data loaded into the working environment, we can 
inspect it. Here are a couple simple commands that are commonly used to 
get an overview of the data:

```{R table_properties, results="hold", comment=NA}

# Number of rows and columns in the table.
print(nrow(gwas))
print(ncol(gwas))
```

These commands show the first 5 columns and the last 5 columns of the 
data frame:

```{R more_table_properties, eval=FALSE}
print(head(gwas,n = 5))
print(tail(gwas,n = 5))
```

## Manipulating the data

We certainly don't have time to look closely at all the GWAS Catalog data.
But we can at least start by looking closely at the "MAPPED_TRAIT" column, 
which indicates which disease or trait was being studied:

```{R chromosome_inspect, comment=NA}

# Our first attempt at summarizing the MAPPED_TRAIT column doesn't yield
# much insight.
print(summary(gwas[["MAPPED_TRAIT"]]))

# What if we convert the column to a categorical variable? That helps,
# but not a lot; there are too many categories, or "levels", for the summary
# to be useful, so I capped the summary at showing only the top 10 most
# common categories (diseases/traits).
trait <- factor(gwas[["MAPPED_TRAIT"]])
print(nlevels(trait))
print(summary(trait,maxsum = 10))

# To make our initial investigation more manageable, let's focus on
# only diseases/traits that appear at least 100 entries (that is,
# reported associations). This is an arbitrary cutoff of course, but
# data analysis is best approached in small bites.
counts         <- table(trait)
traits.to.keep <- which(counts >= 100)
cat("Number of traits after filtering step:",length(traits.to.keep),"\n")
gwas.small <- subset(gwas,is.element(MAPPED_TRAIT,names(traits.to.keep)))
cat("Number of table rows after filtering step:",nrow(gwas.small))

# Now that MAPPED_TRAIT in the gwas.small data frame has a smaller
# number of categories (levels), let's convert that column to a 
# factor.
gwas.small$MAPPED_TRAIT <- factor(gwas.small$MAPPED_TRAIT)
```

A few comments about this chunk of code:

+ The `summary` function is a genetic function that can be used for many 
  different variables and data types. You will find it useful in many 
  situations.

+ A "factor" is a term that R uses for a categorical variable. It is one
  of the standard data types, and is again useful in many different
  situations.

+ The `table` command (a confusing name, admittedly) is used to count
  categorical data (factors).

+ The call to the `subset` function creates a new data table, `gwas.small`,
  with only entries for the selected diseases/traits. We now have two
  data frames in our working environment: `gwas` and `gwas.small`. 

+ The last line in the chunk converts the column to a factor data type,
  which will be useful in the next section for quickly creating data 
  summaries.

For the remainder, we will work with `gwas.small` only.

## Creating a simple visual summary of the data

Counting the number of genetic associations per disease/trait is as simple 
as calling the `summary` function:

```{R summary_trait, comment=NA}
print(summary(gwas.small$MAPPED_TRAIT))
```

That's not bad, but a figure is almost always more effective than a table 
for gaining insight. Let's create one using the `ggplot2` package, which 
has emerged as the most popular approach for plotting in R because it
is easy to use (after getting a hang of the unconventional interface) and
powerful.

```{R trait_summary_plot, fig.height=7.5}
library(ggplot2)
print(ggplot(gwas.small,aes(MAPPED_TRAIT)) +
  geom_bar(fill = "darkorange",width = 0.5) + 
  coord_flip() +
  theme_minimal() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()))
```

It is difficult to understand how `ggplot` works with one example, and
we won't attempt to do that here. Here are a few messages to take away from
this example:

+ It is most natural to use `ggplot` with data frames; the `aes` function
  tells `ggplot` which columns to visualize.
  
+ After the `geom_bar` call, the rest of the function calls adjust
  the properties of the figure, and aren't necessary.

**Exercise:** Use the `reorder` function to create a new bar plot 
in which the traits are listed in increasing or decreasing order by 
the number of associations.

## Looking at the relationship between two columns for a given disease:

Demonstrate definition of a function.

```{R effect_sizes, comment=NA, warning=FALSE, eval=FALSE}

# Extract the two columns we are interested in.
tbl <- data.frame(x = gwas[["OR or BETA"]],
                  y = log10(as.numeric(gwas[["RISK ALLELE FREQUENCY"]])),
                  z = log10(gwas[["P-VALUE"]]),
                  a = factor(gwas[["STUDY ACCESSION"]]),
                  trait = gwas$MAPPED_TRAIT,
                  gene = gwas$MAPPED_GENE,
                  hla = factor(grepl("HLA",gwas[["REPORTED GENE(S)"]]),
                               c("TRUE","FALSE"),c("HLA","")))
tbl <- subset(tbl,trait == "schizophrenia")
tbl <- subset(tbl,z < (-10))
tbl$a <- factor(as.charcter(tbl$a))

# First attempt at a summary of effect sizes; turns out to not be very 
# informative.
print(summary(tbl$x))

# An attempt at a more informative summary of effect sizes.
print(quantile(tbl$x,probs = seq(0,1,0.1),na.rm = TRUE))

# Based on this, let's "clean up" the strange values of the effect sizes.
rows <- with(tbl,which(x <= 0 | x > 4))
tbl[rows,"x"] <- NA

# First attempt at summary of p-values.
print(summary(tbl$y))

# Not bad; let's look at the distribution of p-values in a little more 
# detail.
print(quantile(tbl$y,probs = seq(0,1,0.1),na.rm = TRUE))

# We need to remove the non-finite values.
rows <- which(tbl$y < (-4))
tbl[rows,"y"] <- NA

summary(lm(y ~ x,tbl))

print(ggplot(tbl,aes(x = x,y = y,color = a,label = hla)) +
  geom_point(size = 2) + 
  geom_text(size = 2.5,hjust = "left",vjust = "top",nudge_x = 0.025,col="black") + 
  theme_minimal())

```

## About this document

*Explain here what this does. Useful for reproducibility.*

```{R session_Info}
sessionInfo()
```
